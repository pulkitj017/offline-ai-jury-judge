
import { Injectable, Logger } from '@nestjs/common';
import axios from 'axios';
import { FileInfo } from '../git/git.service';

interface CommitInfo {
  hash: string;
  author: string;
  email: string;
  timestamp: string;
  message: string;
  changedFiles: string[];
  diff: string;
}

interface ReviewRequest {
  problemStatement: string;
  teamSummary: string;
  commitHistory: CommitInfo[];
  files: FileInfo[];
}

interface ReviewScores {
  aiContribution: number;
  security: number;
  scalability: number;
  architecture: number;
  costOptimization: number;
  total: number;
}

interface ReviewExplanations {
  aiContribution: string;
  security: string;
  scalability: string;
  architecture: string;
  costOptimization: string;
  applicationStatus: string;
}

export interface ReviewResponse {
  scores: ReviewScores;
  explanations: ReviewExplanations;
}

@Injectable()
export class ReviewService {
  private readonly logger = new Logger(ReviewService.name);

  async reviewTeamCode(reviewData: ReviewRequest): Promise<ReviewResponse> {
    try {
      // First, analyze the commit messages to detect AI vs human
      const commitReview = await this.reviewCommitMessages(reviewData.commitHistory);
      
      // Second, analyze the file contents for more detailed review
      const fileReview = await this.reviewFileContents(reviewData.files, reviewData.problemStatement);
      
      // Combine the results
      return this.combineReviews(commitReview, fileReview);
    } catch (error) {
      this.logger.error(`Error reviewing team code: ${error.message}`);
      return this.getDefaultReviewResponse();
    }
  }

  private async reviewCommitMessages(commits: CommitInfo[]): Promise<{
    aiContributionScore: number;
    aiContributionExplanation: string;
  }> {
    const formattedCommits = commits.map(commit => ({
      hash: commit.hash,
      author: commit.author,
      email: commit.email,
      timestamp: commit.timestamp,
      message: commit.message
    }));

    const prompt = `
You are an expert AI jury for a hackathon. I need you to analyze these commit messages and determine how likely they were written by a human or generated by AI.

Commit Messages:
${JSON.stringify(formattedCommits, null, 2)}

When analyzing, consider:
1. Commit message meaningfulness and clarity
2. Natural language patterns
3. Spelling accuracy and grammar
4. Specificity of descriptions
5. Consistency in style and tone
6. Presence of typical human elements (typos, abbreviations, emotion)
7. Patterns that suggest AI generation

Return a score from 0-10 where:
0 = Definitely all human-written
10 = Definitely all AI-generated

Also provide a detailed explanation for your score, citing specific examples from the commit messages.

Return your evaluation in this exact JSON format:
{
  "aiContributionScore": 0,
  "aiContributionExplanation": ""
}
`;

    try {
      const response = await axios.post('http://localhost:11434/api/chat', {
        model: 'llama3.1:latest',
        messages: [{ role: 'user', content: prompt }],
        stream: false,
      }, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer psai_eb1856936c7646b1914d2ba64317997e`,
        },
      });

      const llamaResponse = response.data.message.content;
      this.logger.log('LLaMA model response received for commit analysis');

      const jsonMatch = llamaResponse.match(/```json\s*([\s\S]*?)\s*```/) || 
                       llamaResponse.match(/{[\s\S]*"aiContributionScore"[\s\S]*"aiContributionExplanation"[\s\S]*}/);
      
      if (jsonMatch) {
        const jsonStr = jsonMatch[0].startsWith('{') ? jsonMatch[0] : jsonMatch[1];
        return JSON.parse(jsonStr);
      } else {
        this.logger.error('Failed to parse JSON from LLaMA response for commit analysis. Using default values.');
        return {
          aiContributionScore: 5,
          aiContributionExplanation: 'Could not analyze commit messages due to parsing error.'
        };
      }
    } catch (error) {
      this.logger.error(`Error analyzing commit messages: ${error.message}`);
      return {
        aiContributionScore: 5,
        aiContributionExplanation: 'Could not analyze commit messages due to an error.'
      };
    }
  }

  private async reviewFileContents(files: FileInfo[], problemStatement: string): Promise<{
    security: number;
    scalability: number;
    architecture: number;
    costOptimization: number;
    securityExplanation: string;
    scalabilityExplanation: string;
    architectureExplanation: string;
    costOptimizationExplanation: string;
    applicationStatus: string;
  }> {
    // Prepare file summaries to not overwhelm the model
    const fileSummaries = files.map(file => ({
      filename: file.filename,
      path: file.path,
      extension: file.extension,
      size: file.size,
      // Include first 500 chars of content or less for preview
      contentPreview: file.content.substring(0, 500) + (file.content.length > 500 ? '...' : '')
    }));

    // For larger codebases, we need to be selective about which files to analyze in detail
    const codeFiles = files.filter(file => 
      ['.js', '.jsx', '.ts', '.tsx', '.py', '.rb', '.java', '.go', '.rs', '.c', '.cpp', '.cs', '.php']
        .some(ext => file.filename.endsWith(ext))
    );

    // Select up to 10 important files for detailed analysis
    const selectedFiles = this.selectImportantFiles(codeFiles);

    const prompt = `
You are an expert AI jury for a hackathon. I need you to analyze this codebase for a project that aims to solve the following problem:

${problemStatement}

File structure overview (${files.length} files total):
${JSON.stringify(fileSummaries, null, 2)}

Detailed analysis of key files:
${selectedFiles.map(file => `
File: ${file.path}
Content:
\`\`\`
${file.content.substring(0, 3000)}${file.content.length > 3000 ? '... (truncated)' : ''}
\`\`\`
`).join('\n')}

Please analyze this codebase for:

1. Security & Access (score 0-10): Evaluate security practices, authentication, authorization, data protection, input validation, and protection against common vulnerabilities.

2. Scalability & Availability (score 0-10): Assess how well the application would scale with increased load, architectural choices that impact performance, and strategies for ensuring availability.

3. Architecture (score 0-10): Review the overall architecture, code organization, modularity, separation of concerns, and adherence to design patterns and best practices.

4. Cost Optimization (score 0-10): Evaluate resource usage efficiency, algorithm complexity, and approaches that might impact operational costs.

5. Final Application Status: Provide a qualitative assessment of the application's completeness, readiness, and overall quality.

For each category, provide a detailed explanation with specific examples from the code. Also provide a final numerical score for each category.

Return your evaluation in this exact JSON format:
{
  "security": 0,
  "scalability": 0,
  "architecture": 0,
  "costOptimization": 0,
  "securityExplanation": "",
  "scalabilityExplanation": "",
  "architectureExplanation": "",
  "costOptimizationExplanation": "",
  "applicationStatus": ""
}
`;

    try {
      const response = await axios.post('http://localhost:11434/api/chat', {
        model: 'llama3.1:latest',
        messages: [{ role: 'user', content: prompt }],
        stream: false,
      }, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer psai_eb1856936c7646b1914d2ba64317997e`,
        },
      });

      const llamaResponse = response.data.message.content;
      this.logger.log('LLaMA model response received for file content analysis');

      const jsonMatch = llamaResponse.match(/```json\s*([\s\S]*?)\s*```/) || 
                       llamaResponse.match(/{[\s\S]*"security"[\s\S]*"applicationStatus"[\s\S]*}/);
      
      if (jsonMatch) {
        const jsonStr = jsonMatch[0].startsWith('{') ? jsonMatch[0] : jsonMatch[1];
        return JSON.parse(jsonStr);
      } else {
        this.logger.error('Failed to parse JSON from LLaMA response for file analysis. Using default values.');
        return this.getDefaultFileReview();
      }
    } catch (error) {
      this.logger.error(`Error analyzing file contents: ${error.message}`);
      return this.getDefaultFileReview();
    }
  }

  private selectImportantFiles(files: FileInfo[]): FileInfo[] {
    // Prioritize important files like:
    // 1. Entry points (index files, main.*)
    // 2. Configuration files
    // 3. Key logic files
    const importanceScore = (file: FileInfo): number => {
      let score = 0;
      
      // Entry points and main files
      if (file.filename.includes('index') || file.filename.includes('main') || 
          file.filename.includes('app') || file.filename === 'server.js') {
        score += 5;
      }
      
      // Config files
      if (file.filename.includes('config') || file.filename.endsWith('.json') ||
          file.filename.endsWith('.yml') || file.filename.endsWith('.yaml')) {
        score += 3;
      }
      
      // Core logic files (often in src/services, src/controllers, etc.)
      if (file.path.includes('/services/') || file.path.includes('/controllers/') ||
          file.path.includes('/models/') || file.path.includes('/middleware/')) {
        score += 4;
      }
      
      // Prioritize based on file size (more code = potentially more important)
      score += Math.min(3, file.size / 5000); // Up to 3 points for files up to 15KB
      
      return score;
    };
    
    // Sort files by importance score and take top 10
    return [...files]
      .sort((a, b) => importanceScore(b) - importanceScore(a))
      .slice(0, 10);
  }

  private combineReviews(
    commitReview: { aiContributionScore: number; aiContributionExplanation: string },
    fileReview: {
      security: number;
      scalability: number;
      architecture: number;
      costOptimization: number;
      securityExplanation: string;
      scalabilityExplanation: string;
      architectureExplanation: string;
      costOptimizationExplanation: string;
      applicationStatus: string;
    }
  ): ReviewResponse {
    // Calculate total score (out of 100)
    const totalScore = (
      commitReview.aiContributionScore +
      fileReview.security +
      fileReview.scalability +
      fileReview.architecture +
      fileReview.costOptimization
    ) * 2.5; // 5 categories, max 10 each, scaling to 100
    
    return {
      scores: {
        aiContribution: commitReview.aiContributionScore,
        security: fileReview.security,
        scalability: fileReview.scalability,
        architecture: fileReview.architecture,
        costOptimization: fileReview.costOptimization,
        total: Math.round(totalScore)
      },
      explanations: {
        aiContribution: commitReview.aiContributionExplanation,
        security: fileReview.securityExplanation,
        scalability: fileReview.scalabilityExplanation,
        architecture: fileReview.architectureExplanation,
        costOptimization: fileReview.costOptimizationExplanation,
        applicationStatus: fileReview.applicationStatus
      }
    };
  }

  private getDefaultFileReview() {
    return {
      security: 5,
      scalability: 5,
      architecture: 5,
      costOptimization: 5,
      securityExplanation: 'Could not evaluate due to an error processing the review.',
      scalabilityExplanation: 'Could not evaluate due to an error processing the review.',
      architectureExplanation: 'Could not evaluate due to an error processing the review.',
      costOptimizationExplanation: 'Could not evaluate due to an error processing the review.',
      applicationStatus: 'Could not determine the application status due to an error in the review process.'
    };
  }

  private getDefaultReviewResponse(): ReviewResponse {
    return {
      scores: {
        aiContribution: 5,
        security: 5,
        scalability: 5,
        architecture: 5,
        costOptimization: 5,
        total: 50,
      },
      explanations: {
        aiContribution: 'Could not evaluate due to an error processing the review.',
        security: 'Could not evaluate due to an error processing the review.',
        scalability: 'Could not evaluate due to an error processing the review.',
        architecture: 'Could not evaluate due to an error processing the review.',
        costOptimization: 'Could not evaluate due to an error processing the review.',
        applicationStatus: 'Could not determine the application status due to an error in the review process.'
      },
    };
  }
}
